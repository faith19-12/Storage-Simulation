<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Pipeline Pressure Simulation</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
   <link rel="stylesheet" href="css/styles.css" />
  <style>
    
    .logo-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .logo {
      height: 50px;
      width: auto;
    }

    nav ul {
      list-style: none;
      padding: 0;
      display: flex;
      gap: 20px;
      margin: 0;
    }

    nav ul li a {
      text-decoration: none;
      color: white;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 4px;
      transition: background-color 0.3s;
    }

    nav ul li a:hover {
      background-color: #0055a5;
    }

    #container {
      width: 100%;
      height: 60vh;
      position: relative;
      flex-grow: 1;
    }

    .controls-panel {
      background-color: #e6f2ff;
      padding: 15px;
      border-bottom: 1px solid #b3d1ff;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 200px;
    }

    label {
      font-weight: bold;
      margin-bottom: 5px;
      color: #003366;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }

    .pressure-info {
      background-color: #f0f8ff;
      padding: 15px;
      margin: 10px auto;
      max-width: 800px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 51, 102, 0.1);
    }

    .pressure-status {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-weight: bold;
    }

    .safe {
      background-color: #d4edda;
      color: #155724;
    }

    .warning {
      background-color: #fff3cd;
      color: #856404;
    }

    .danger {
      background-color: #f8d7da;
      color: #721c24;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .valve-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .valve-btn {
      padding: 8px 15px;
      background-color: #003366;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .valve-btn:hover {
      background-color: #0055a5;
    }

    .valve-status {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #6c757d;
    }

    .valve-open {
      background-color: #28a745;
    }

    .valve-closed {
      background-color: #dc3545;
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        text-align: center;
      }
      
      nav ul {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .controls-panel {
        flex-direction: column;
        align-items: center;
      }
      
      #container {
        height: 50vh;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo-container">
      <img src="assets/logo.jpg" alt="Company Logo" class="logo" />
      <h1>3D Pipeline Pressure Simulation</h1>
    </div>
    </header>
    <nav class="main-nav">
      <ul>
        <li><a href="index.html">Dashboard</a></li>
        <li><a href="storage.html">3D Storage</a></li>
        <li><a href="pressure.html">Pipeline Pressure</a></li>
        <li><a href="route.html">Transport Route</a></li>
        <li><a href="safety.html">Safety Scenario</a></li>
      </ul>
    </nav>
  

  <div class="controls-panel">
    <div class="control-group">
      <label for="pressureSlider">Pressure (PSI)</label>
      <input type="range" id="pressureSlider" min="0" max="150" value="50">
      <div id="pressureValue">50 PSI</div>
    </div>

    <div class="control-group">
      <label for="flowRate">Flow Rate (m¬≥/h)</label>
      <input type="range" id="flowRate" min="0" max="1000" value="500">
      <div id="flowValue">500 m¬≥/h</div>
    </div>

    <div class="control-group valve-control">
      <label>Main Valve</label>
      <button id="valveToggle" class="valve-btn">Close Valve</button>
      <div id="valveStatus" class="valve-status valve-open"></div>
    </div>

    <div class="control-group">
      <label>Emergency Release</label>
      <button id="emergencyRelease" class="valve-btn" style="background-color: #dc3545;">Activate</button>
    </div>
  </div>

  <div id="container"></div>

  <div class="pressure-info">
    <h3>Pipeline Status</h3>
    <div id="pressureStatus" class="pressure-status safe">‚úÖ Normal Operating Pressure</div>
    <div id="pressureDetails">
      <p><strong>Current Pressure:</strong> <span id="currentPressure">50</span> PSI</p>
      <p><strong>Flow Rate:</strong> <span id="currentFlow">500</span> m¬≥/h</p>
      <p><strong>Valve Status:</strong> <span id="valveState">Open</span></p>
      <p id="pressureWarning" style="display: none; color: #856404;">‚ö†Ô∏è Warning: Pressure approaching maximum operating limit</p>
      <p id="pressureDanger" style="display: none; color: #721c24;">üî• DANGER: Pressure exceeds safe limits! Activate emergency release!</p>
    </div>
  </div>

  <script>
    // Three.js Scene Setup
    let scene, camera, renderer, pipeline, controls;
    let pressure = 50;
    let flowRate = 500;
    let valveOpen = true;
    let emergencyActivated = false;

    // Pressure thresholds
    const WARNING_PRESSURE = 100;
    const DANGER_PRESSURE = 120;
    const MAX_PRESSURE = 150;

    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f8ff);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight * 0.6), 0.1, 1000);
      camera.position.set(0, 2, 8);

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
      renderer.shadowMap.enabled = true;
      document.getElementById('container').appendChild(renderer.domElement);

      // Add orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Create pipeline
      createPipeline();

      // Add ground
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add grid helper
      const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x666666);
      scene.add(gridHelper);

      // Handle window resize
      window.addEventListener('resize', onWindowResize);

      // Setup controls
      setupControls();

      // Start animation loop
      animate();
    }

    function createPipeline() {
      // Remove existing pipeline if any
      if (pipeline) {
        scene.remove(pipeline);
      }

      // Create pipeline group
      pipeline = new THREE.Group();

      // Main pipeline parameters
      const pipeRadius = 0.3;
      const pipeLength = 8;
      const pipeSegments = 32;
      const pipeColor = getPressureColor(pressure);

      // Main pipe
      const pipeGeometry = new THREE.CylinderGeometry(
        pipeRadius,
        pipeRadius,
        pipeLength,
        pipeSegments,
        1,
        true
      );
      const pipeMaterial = new THREE.MeshStandardMaterial({
        color: pipeColor,
        roughness: 0.4,
        metalness: 0.7,
        emissive: pressure > DANGER_PRESSURE ? 0xff0000 : 0x000000,
        emissiveIntensity: pressure > DANGER_PRESSURE ? 0.3 : 0
      });
      const mainPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
      mainPipe.rotation.z = Math.PI / 2;
      mainPipe.position.x = -pipeLength / 2;
      pipeline.add(mainPipe);

      // Add valves
      addValve(pipeline, -2, pipeRadius);
      addValve(pipeline, 2, pipeRadius);

      // Add pressure gauge
      addPressureGauge(pipeline, 0, pipeRadius);

      // Add support structures
      for (let i = -3; i <= 3; i++) {
        addPipelineSupport(pipeline, i * 2.5, pipeRadius);
      }

      // Add flow indicators if valve is open
      if (valveOpen && flowRate > 0) {
        addFlowIndicators(pipeline, pipeLength, pipeRadius, flowRate);
      }

      scene.add(pipeline);
    }

    function addValve(parent, xPos, pipeRadius) {
      const valveGroup = new THREE.Group();
      valveGroup.position.x = xPos;

      // Valve body
      const valveBodyGeometry = new THREE.CylinderGeometry(
        pipeRadius * 1.5,
        pipeRadius * 1.5,
        pipeRadius * 1.2,
        6
      );
      const valveBodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.3,
        metalness: 0.9
      });
      const valveBody = new THREE.Mesh(valveBodyGeometry, valveBodyMaterial);
      valveGroup.add(valveBody);

      // Valve handle
      const handleGeometry = new THREE.CylinderGeometry(
        pipeRadius * 0.1,
        pipeRadius * 0.1,
        pipeRadius * 2,
        8
      );
      const handleMaterial = new THREE.MeshStandardMaterial({
        color: valveOpen ? 0x28a745 : 0xdc3545,
        roughness: 0.4,
        metalness: 0.6
      });
      const handle = new THREE.Mesh(handleGeometry, handleMaterial);
      handle.position.y = pipeRadius * 0.6;
      handle.rotation.z = valveOpen ? Math.PI / 4 : Math.PI / 2;
      valveGroup.add(handle);

      // Connection flanges
      for (let i = -1; i <= 1; i += 2) {
        const flangeGeometry = new THREE.CylinderGeometry(
          pipeRadius * 1.2,
          pipeRadius * 1.2,
          pipeRadius * 0.2,
          6
        );
        const flange = new THREE.Mesh(flangeGeometry, valveBodyMaterial);
        flange.position.x = i * (pipeRadius * 1.2);
        valveGroup.add(flange);
      }

      parent.add(valveGroup);
    }

    function addPressureGauge(parent, xPos, pipeRadius) {
      const gaugeGroup = new THREE.Group();
      gaugeGroup.position.x = xPos;
      gaugeGroup.position.y = pipeRadius * 2;

      // Gauge body
      const gaugeGeometry = new THREE.CylinderGeometry(
        pipeRadius * 1.5,
        pipeRadius * 1.5,
        pipeRadius * 0.3,
        32
      );
      const gaugeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.8
      });
      const gauge = new THREE.Mesh(gaugeGeometry, gaugeMaterial);
      gaugeGroup.add(gauge);

      // Gauge face
      const faceGeometry = new THREE.CylinderGeometry(
        pipeRadius * 1.4,
        pipeRadius * 1.4,
        pipeRadius * 0.1,
        32
      );
      const faceMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.8,
        metalness: 0.1
      });
      const face = new THREE.Mesh(faceGeometry, faceMaterial);
      face.position.z = pipeRadius * 0.16;
      gaugeGroup.add(face);

      // Needle
      const needleGeometry = new THREE.BoxGeometry(
        pipeRadius * 1.3,
        pipeRadius * 0.05,
        pipeRadius * 0.05
      );
      const needleMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.3,
        metalness: 0.7
      });
      const needle = new THREE.Mesh(needleGeometry, needleMaterial);
      needle.position.z = pipeRadius * 0.2;
      
      // Calculate needle rotation based on pressure
      const pressureRatio = pressure / MAX_PRESSURE;
      needle.rotation.z = -Math.PI / 2 + (Math.PI * pressureRatio);
      gaugeGroup.add(needle);

      parent.add(gaugeGroup);
    }

    function addPipelineSupport(parent, xPos, pipeRadius) {
      const supportGroup = new THREE.Group();
      supportGroup.position.x = xPos;

      // Support base
      const baseGeometry = new THREE.BoxGeometry(
        pipeRadius * 2,
        pipeRadius * 0.5,
        pipeRadius * 2
      );
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x555555,
        roughness: 0.7,
        metalness: 0.3
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -pipeRadius * 0.75;
      supportGroup.add(base);

      // Support column
      const columnGeometry = new THREE.CylinderGeometry(
        pipeRadius * 0.3,
        pipeRadius * 0.3,
        pipeRadius * 1.5,
        8
      );
      const column = new THREE.Mesh(columnGeometry, baseMaterial);
      column.position.y = -pipeRadius * 0.25;
      supportGroup.add(column);

      // Pipe clamp
      const clampGeometry = new THREE.TorusGeometry(
        pipeRadius * 1.1,
        pipeRadius * 0.2,
        8,
        16,
        Math.PI
      );
      const clamp = new THREE.Mesh(clampGeometry, baseMaterial);
      clamp.position.y = pipeRadius * 0.5;
      clamp.rotation.x = Math.PI / 2;
      supportGroup.add(clamp);

      parent.add(supportGroup);
    }

    function addFlowIndicators(parent, pipeLength, pipeRadius, flowRate) {
      const flowIntensity = Math.min(flowRate / 500, 1.5);
      const particleCount = Math.floor(flowIntensity * 50);
      
      // Create particle system for flow visualization
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0x00aaff,
        size: pipeRadius * 0.5,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
      });

      const positions = new Float32Array(particleCount * 3);
      const speeds = new Float32Array(particleCount);
      
      // Initialize particles
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() * pipeLength) - (pipeLength / 2);
        positions[i * 3 + 1] = (Math.random() * 0.2) - 0.1;
        positions[i * 3 + 2] = (Math.random() * 0.2) - 0.1;
        speeds[i] = 0.02 + Math.random() * 0.03 * flowIntensity;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      particles.userData = { speeds: speeds };
      parent.add(particles);
    }

    function getPressureColor(pressure) {
      if (pressure < WARNING_PRESSURE) {
        return 0x22c55e; // Green
      } else if (pressure < DANGER_PRESSURE) {
        return 0xfacc15; // Yellow
      } else {
        return 0xdc2626; // Red
      }
    }

    function setupControls() {
      // Pressure slider
      const pressureSlider = document.getElementById('pressureSlider');
      pressureSlider.addEventListener('input', () => {
        pressure = parseInt(pressureSlider.value);
        document.getElementById('pressureValue').textContent = `${pressure} PSI`;
        document.getElementById('currentPressure').textContent = pressure;
        updatePressureStatus();
        createPipeline();
      });

      // Flow rate slider
      const flowRateSlider = document.getElementById('flowRate');
      flowRateSlider.addEventListener('input', () => {
        flowRate = parseInt(flowRateSlider.value);
        document.getElementById('flowValue').textContent = `${flowRate} m¬≥/h`;
        document.getElementById('currentFlow').textContent = flowRate;
        
        // Adjust pressure based on flow rate if valve is open
        if (valveOpen) {
          const newPressure = Math.min(50 + (flowRate / 20), MAX_PRESSURE);
          pressureSlider.value = newPressure;
          pressure = newPressure;
          document.getElementById('pressureValue').textContent = `${pressure} PSI`;
          document.getElementById('currentPressure').textContent = pressure;
          updatePressureStatus();
          createPipeline();
        }
      });

      // Valve toggle
      const valveToggle = document.getElementById('valveToggle');
      const valveStatus = document.getElementById('valveStatus');
      document.getElementById('valveToggle').addEventListener('click', () => {
        valveOpen = !valveOpen;
        
        if (valveOpen) {
          valveToggle.textContent = 'Close Valve';
          valveStatus.className = 'valve-status valve-open';
          document.getElementById('valveState').textContent = 'Open';
          
          // Reset flow rate when opening valve
          flowRateSlider.value = 500;
          flowRate = 500;
          document.getElementById('flowValue').textContent = '500 m¬≥/h';
          document.getElementById('currentFlow').textContent = '500';
        } else {
          valveToggle.textContent = 'Open Valve';
          valveStatus.className = 'valve-status valve-closed';
          document.getElementById('valveState').textContent = 'Closed';
          
          // Set flow to zero when closing valve
          flowRateSlider.value = 0;
          flowRate = 0;
          document.getElementById('flowValue').textContent = '0 m¬≥/h';
          document.getElementById('currentFlow').textContent = '0';
        }
        
        createPipeline();
      });

      // Emergency release
      document.getElementById('emergencyRelease').addEventListener('click', () => {
        if (!emergencyActivated) {
          emergencyActivated = true;
          valveOpen = false;
          pressure = 0;
          flowRate = 0;
          
          // Update controls
          pressureSlider.value = 0;
          flowRateSlider.value = 0;
          valveToggle.textContent = 'Open Valve';
          valveStatus.className = 'valve-status valve-closed';
          document.getElementById('valveState').textContent = 'Closed (Emergency)';
          document.getElementById('pressureValue').textContent = '0 PSI';
          document.getElementById('flowValue').textContent = '0 m¬≥/h';
          document.getElementById('currentPressure').textContent = '0';
          document.getElementById('currentFlow').textContent = '0';
          
          // Update status
          document.getElementById('pressureStatus').className = 'pressure-status safe';
          document.getElementById('pressureStatus').textContent = '‚úÖ Emergency Release Activated';
          document.getElementById('pressureWarning').style.display = 'none';
          document.getElementById('pressureDanger').style.display = 'none';
          
          createPipeline();
          
          // Reset after 3 seconds
          setTimeout(() => {
            emergencyActivated = false;
            document.getElementById('emergencyRelease').style.backgroundColor = '#dc3545';
          }, 3000);
        }
      });
    }

    function updatePressureStatus() {
      const statusElement = document.getElementById('pressureStatus');
      const warningElement = document.getElementById('pressureWarning');
      const dangerElement = document.getElementById('pressureDanger');
      
      if (pressure < WARNING_PRESSURE) {
        statusElement.className = 'pressure-status safe';
        statusElement.textContent = '‚úÖ Normal Operating Pressure';
        warningElement.style.display = 'none';
        dangerElement.style.display = 'none';
      } else if (pressure < DANGER_PRESSURE) {
        statusElement.className = 'pressure-status warning';
        statusElement.textContent = '‚ö†Ô∏è High Pressure Warning';
        warningElement.style.display = 'block';
        dangerElement.style.display = 'none';
      } else {
        statusElement.className = 'pressure-status danger';
        statusElement.textContent = 'üî• DANGER: CRITICAL PRESSURE!';
        warningElement.style.display = 'none';
        dangerElement.style.display = 'block';
        document.getElementById('emergencyRelease').style.backgroundColor = '#ff0000';
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / (window.innerHeight * 0.6);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Update flow particles if valve is open
      if (valveOpen && flowRate > 0 && pipeline) {
        const particles = pipeline.children.find(child => child instanceof THREE.Points);
        if (particles) {
          const positions = particles.geometry.attributes.position.array;
          const speeds = particles.userData.speeds;
          
          for (let i = 0; i < positions.length / 3; i++) {
            positions[i * 3] += speeds[i];
            
            // Wrap particles around when they reach the end
            if (positions[i * 3] > pipeline.children[0].geometry.parameters.height / 2) {
              positions[i * 3] = -pipeline.children[0].geometry.parameters.height / 2;
            }
          }
          
          particles.geometry.attributes.position.needsUpdate = true;
        }
      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    // Initialize the scene
    init();
  </script>
</body>
</html>

